---
output: html_document
---
---
title: "<center><h1>Prediction models for 
House Prices dataset</h1></center>"
author: 
  "<center>Navya Mote</center>"
date: "<center>May 2, 2018</center>"
---
For the cleaning we took reference from https://www.kaggle.com/tannercarbonati/detailed-data-analysis-ensemble-modeling

```{r warning=FALSE, message=FALSE}
require(ggplot2) # for data visualization
require(stringr) #extracting string patterns
require(Matrix) # matrix transformations
require(glmnet) # ridge, lasso & elastinet
require(xgboost) # gbm
require(randomForest)
require(Metrics) # rmse
require(dplyr) # load this in last so plyr doens't overlap it
require(caret) # one hot encoding
require(scales) # plotting $$
require(e1071) # skewness
require(corrplot) # correlation plot
```

The first thing we'll do is load in the training and testing data. The training data consists of 1460 rows and 81 columns while the testing has 1459 rows and 80 columns (excluding the `SalePrice` column), which in this dataset is the dependent variable we are trying to predict. For us to perform analysis at a more productive rate we can combine the 2 dataframes together and run analysis on both data sets at once, then split the data once we are ready to train a model. 

The `Id` feature is useless so we can toss it out of our dataset and we won't include `SalePrice` since it is our response variable. We also won't import string variables as factors since our ultimate goal is to tranform all our variables to numeric.Removing 'FireplaceQu' and 'LotFrontage' significantly improved our predictions. 

```{r warning=FALSE, message=FALSE}
train <- read.csv('C:/Users/Navya/Desktop/OR568/House price/train.csv', stringsAsFactors = FALSE)
test <- read.csv('C:/Users/Navya/Desktop/OR568/House price/test.csv', stringsAsFactors = FALSE)


# combine the datasets
df.combined <- rbind(within(train, rm('Id','SalePrice','FireplaceQu','LotFrontage')), within(test, rm('Id','FireplaceQu','LotFrontage')))
dim(df.combined)
```

Our dataset is filled with many missing values, therefore, before we can build any predictive model we'll clean our data by filling in all NA's with appropriate values. For each column we'll try to replace NA's by using features that have a strong correlation, which will help us determine what values to fill in. 

```{r warning=FALSE, message=FALSE}
na.cols <- which(colSums(is.na(df.combined)) > 0)
sort(colSums(sapply(df.combined[na.cols], is.na)), decreasing = TRUE)
paste('There are', length(na.cols), 'columns with missing values')
```

```{r}
# helper function for plotting categoric data for easier data visualization
plot.categoric <- function(cols, df){
  for (col in cols) {
    order.cols <- names(sort(table(df.combined[,col]), decreasing = TRUE))
  
    num.plot <- qplot(df[,col]) +
      geom_bar(fill = 'cornflowerblue') +
      geom_text(aes(label = ..count..), stat='count', vjust=-0.5) +
      theme_minimal() +
      scale_y_continuous(limits = c(0,max(table(df[,col]))*1.1)) +
      scale_x_discrete(limits = order.cols) +
      xlab(col) +
      theme(axis.text.x = element_text(angle = 30, size=12))
  
    print(num.plot)
  }
}

```

**PoolQC: Pool quality**

There are 2909 missing values in PoolQC, which represents the quality of the houses pool. It is a reasonable assumption that houses with NA's for PoolQC most likely don't have a pool, however, for us to check this we can see if any of the houses that have a NA for PoolQC recorded a PoolArea > 0 (**PoolArea:** Pool area in square feet). it is safe to assume that houses with a PoolArea of 0 don't have a pool and for those greater than 0 do. 

```{r warning=FALSE, message=FALSE}
plot.categoric('PoolQC', df.combined)
df.combined[(df.combined$PoolArea > 0) & is.na(df.combined$PoolQC),c('PoolQC','PoolArea')]
```

Of the 2909 houses with NA's for PoolQC only 3 recorded a PoolArea greater than 0. To fill the missing values for these houses we can see what the mean pool area is for each quality of pool. To do this we'll group by each unique vlaue of `PoolQC` and compute the mean of PoolArea for that quality. Once we have the mean areas computed we can assign the quality that has the closest corresponding mean of PoolArea

```{r warning=FALSE, message=FALSE}
df.combined[,c('PoolQC','PoolArea')] %>%
  group_by(PoolQC) %>%
  summarise(mean = mean(PoolArea), counts = n()) 

```

Note that only 10 houses total have pools  The rest of the houses PoolQC can be filled with 'NoPool' since each has a corresponding PoolArea of 0. We'll fill in the 3 PoolQC's from above with the quality having the closest corresponding mean. 


```{r warning=FALSE, message=FALSE}
df.combined[2421,'PoolQC'] = 'Ex'
df.combined[2504,'PoolQC'] = 'Ex'
df.combined[2600,'PoolQC'] = 'Fa'
df.combined$PoolQC[is.na(df.combined$PoolQC)] = 'None'
```

**GarageType: Garage location**  
**GarageYrBlt: Year garage was built**  
**GarageFinish: Interior finish of the garage**  
**GarageCars: Size of garage in car capacity**  
**GarageArea: Size of garage in square feet**  
**GarageQual: Garage quality**  
**GarageCond: Garage condition**  

Lets see what the deal is with `GarageYrBlt`. It seems reasonable that most houses would build a garage when the house itself was built. We can check this by seeing how many houses were built the same year their garage was built. 


```{r}
length(which(df.combined$GarageYrBlt == df.combined$YearBuilt))
```

2216 of the 2919 houses have same year for for GarageYrBlt and YearBuilt. Lets replace any of the NA's for `GarageYrBlt` with the year from  `YearBuilt`. 

```{r}
idx <- which(is.na(df.combined$GarageYrBlt))
df.combined[idx, 'GarageYrBlt'] <- df.combined[idx, 'YearBuilt']
```

That leaves 6 garage features in our dataset and 4 of them have at least 157 missing values while `GarageArea` and `GarageCars` both only have 1, thus we can assume this particular house does not have a garage at all. For the rest of the houses we can check to see that if the NA's recorded also have 0 GarageArea and 0 GarageCars. If they do we can fill in their missing values with 'None' since having 0 area and 0 cars in their garage will imply that they do not have any at all. 

```{r}
garage.cols <- c('GarageArea', 'GarageCars', 'GarageQual', 'GarageFinish', 'GarageCond', 'GarageType')
df.combined[is.na(df.combined$GarageCond),garage.cols]
```

Only one house who had NA's in their garage columns had an area graeteer than 0. We can fill this house in manually and set the rest of the houses NA's to 0. 

For the house with *GarageArea = 360* and *GarageCars = 1*, but NA's in the other columns, we can use the most frequent values for each columns from houses with a similar area and car count. 

```{r warning=FALSE, message=FALSE}
idx <- which(((df.combined$GarageArea < 370) & (df.combined$GarageArea > 350)) & (df.combined$GarageCars == 1))

names(sapply(df.combined[idx, garage.cols], function(x) sort(table(x), decreasing=TRUE)[1]))
  
df.combined[2127,'GarageQual'] = 'TA'
df.combined[2127, 'GarageFinish'] = 'Unf'
df.combined[2127, 'GarageCond'] = 'TA'
```

Now we can fill in any missing numeric values with 0 and categoric with 'None' since these houses recorded having 0 area and 0 cars in their garage.

```{r warning=FALSE, message=FALSE}
for (col in garage.cols){
  if (sapply(df.combined[col], is.numeric) == TRUE){
    df.combined[sapply(df.combined[col], is.na), col] = 0
  }
  else{
    df.combined[sapply(df.combined[col], is.na), col] = 'None'
  }
}
```

**KitchenQual: Kitchen quality**  
**Electrical: Electrical system**  

With only 1 missing value for `KitchenQual` and `Electrical` each we can fill in the missing value with the most frequent value from each column. 

```{r warning=FALSE, message=FALSE}
plot.categoric('KitchenQual', df.combined)
df.combined$KitchenQual[is.na(df.combined$KitchenQual)] = 'TA'

plot.categoric('Electrical', df.combined)
df.combined$Electrical[is.na(df.combined$Electrical)] = 'SBrkr'
```

- **BsmtQual: Height of the basement**  
- **BsmtCond: General condition of the basement**  
- **BsmtExposure: Walkout or garden level basement walls**  
- **BsmtFinType1: Quality of basement finished area**  
- **BsmtFinSF1: Type 1 finished square feet**  
- **BsmtFinType2: Quality of second finished area (if present)**  
- **BsmtFinSF2: Type 2 finished square feet**  
- **BsmtUnfSF: Unfinished square feet of basement area**  
- **TotalBsmtSF: Total square feet of basement area**  
- **BsmtFullBath: Basement full bathrooms**  
- **BsmtHalfBath: Basement half bathrooms**  

There are 11 basement features each with at least 1 missing value. We can take a look at the subset of just these columns from our data.

```{r warning=FALSE, message=FALSE}

bsmt.cols <- names(df.combined)[sapply(names(df.combined), function(x) str_detect(x, 'Bsmt'))]

df.combined[is.na(df.combined$BsmtExposure),bsmt.cols]
plot.categoric('BsmtExposure', df.combined)
```

Almost all of the missing values for  each categoric basement feature comes from houses with 0 on each features corresponding to area. We can fill in these values with 'None' since these houses certainly don't have basements. Rows 949, 1488 and 2349 are the only missing values from BsmtExposure, we can fill this with *No* as that is the most frequent value and these houses most likely don't have any exposure for their basements. The rest of the basement columns corresponding to area will be filled with 0 since they likely don't have a basement and the categoric missing values will be filled with *NoBsmt*. 

```{r warning=FALSE, message=FALSE}
df.combined[c(949, 1488, 2349), 'BsmtExposure'] = 'No'

for (col in bsmt.cols){
  if (sapply(df.combined[col], is.numeric) == TRUE){
    df.combined[sapply(df.combined[col], is.na),col] = 0
  }
  else{
    df.combined[sapply(df.combined[col],is.na),col] = 'None'
  }
}
```

- **Exterior1st: Exterior covering on house**  
- **Exterior2nd: Exterior covering on house (if more than one material)** 

```{r warning = FALSE, message=FALSE}
#plot.categoric(c('Exterior1st', 'Exterior2nd'), df.combined)
idx <- which(is.na(df.combined$Exterior1st) | is.na(df.combined$Exterior2nd))
df.combined[idx,c('Exterior1st', 'Exterior2nd')]
```

There is only 1 missing value for `Exterior1st` and `Exterior2nd` coming from the same hosue and there aren't any other features that can help us predict what variable should be filled so we can fill this with *'Other'* since the NA is likely due to having an exterior cover that is not listed. 

```{r warning=FALSE, message=FALSE}
df.combined$Exterior1st[is.na(df.combined$Exterior1st)] = 'Other'
df.combined$Exterior2nd[is.na(df.combined$Exterior2nd)] = 'Other'

```

- **SaleType: Type of sale**  
- **Functional: Home functionality rating**  
- **Utilities: Type of utilities available**  

`SaleType`, `Functional` and `Utilities` have less than 3 missing values. For SaleType we can see what the SaleCondition of the house was and use a contingency table to see which SaleType and SaleCondition overlap together the most. 

```{r warning=FALSE, message=FALSE}
plot.categoric('SaleType', df.combined)

df.combined[is.na(df.combined$SaleType),c('SaleCondition')]

table(df.combined$SaleCondition, df.combined$SaleType)
```

Most houses with a SaleCondition of 'Normal' almost all have a SaleType of 'WD'. We'll replace the missing value accordingly. 

```{r warning=FALSE, message=FALSE}
df.combined$SaleType[is.na(df.combined$SaleType)] = 'WD'

plot.categoric('Functional', df.combined)
df.combined$Functional[is.na(df.combined$Functional)] = 'Typ'
```

Utilities only has 1 value for NoSeWa and the rest AllPub. We can drop this feature from our dataset as the house with 'NoSeWa' is from our training set and will have won't help with any predictive modelling

```{r warning=FALSE, message=FALSE}
plot.categoric('Utilities', df.combined)
which(df.combined$Utilities == 'NoSeWa') # in the training data set


col.drops <- c('Utilities')
df.combined <- df.combined[,!names(df.combined) %in% c('Utilities')]
```

- **MSZoning: The general zoning classification**  
- **MSSubClass: The building class**  


There are only 4 missing values for MSZoning. We can see what the subclass is for the houses with missing values for Zoning.

```{r warning=FALSE, message=FALSE}
df.combined[is.na(df.combined$MSZoning),c('MSZoning','MSSubClass')]
plot.categoric('MSZoning', df.combined)

table(df.combined$MSZoning, df.combined$MSSubClass)
```

For Subclasses with 20 'RL' has the largest frequency, however, for Subclasses with 30 and 70 'RM' has the most frequency. We will fill the missing values accordingly. 

```{r warning=FALSE, message=FALSE}
df.combined$MSZoning[c(2217, 2905)] = 'RL'
df.combined$MSZoning[c(1916, 2251)] = 'RM'
```

- **MasVnrType: Masonry veneer type**  
- **MasVnrArea: Masonry veneer area in square feet**

There are 23 missing values for `MasVnrArea` and 24 for `MasVnrType`. We can see if both missing values come from the same houses

```{r warning=FALSE, message=FALSE}
df.combined[(is.na(df.combined$MasVnrType)) | (is.na(df.combined$MasVnrArea)), c('MasVnrType', 'MasVnrArea')]
```

All but one house has missing values for both columns. For houses with NA's on both columns we can fill 0 for the area and None for the type since they likely do not have a masonry veneer. For the house with a MasVnrArea of 198 but NA for MasVnrType we can record the median areas for each type and see which type is closest to 198

```{r warning=FALSE, message=FALSE}
na.omit(df.combined[,c('MasVnrType','MasVnrArea')]) %>%
  group_by(na.omit(MasVnrType)) %>%
  summarise(MedianArea = median(MasVnrArea,na.rm = TRUE), counts = n()) %>%
  arrange(MedianArea)

#plot.categoric('MasVnrType', df.combined)

df.combined[2611, 'MasVnrType'] = 'BrkFace'
```

The areas we can replace with 0 and types can be replaced with 'None'

```{r warning=FALSE, message=FALSE}
df.combined$MasVnrType[is.na(df.combined$MasVnrType)] = 'None'
df.combined$MasVnrArea[is.na(df.combined$MasVnrArea)] = 0
```

<!-- - **LotFrontage: Linear feet of street connected to property**   -->

<!-- There are 486 missing values for LotFrontage, which is quite a lot of values to fill and we can't just replace these with 0. We're given that "LotFrontage: Linear feet of street connected to property." The area of each street connected to the house property is most likely going to have a similar area to other houses in its neighborhood. We can group by each neighborhood and take the median of each LotFrontage and fill the missing values of each LotFrontage based on what neighborhood the house comes from.  -->

```{r warning=FALSE, message=FALSE}
# 
# df.combined['Nbrh.factor'] <- factor(df.combined$Neighborhood, levels = unique(df.combined$Neighborhood))
# 
# lot.by.nbrh <- df.combined[,c('Neighborhood','LotFrontage')] %>%
#   group_by(Neighborhood) %>%
#   summarise(median = median(LotFrontage, na.rm = TRUE))
# lot.by.nbrh
# 
# idx = which(is.na(df.combined$LotFrontage))
# 
# for (i in idx){
#   lot.median <- lot.by.nbrh[lot.by.nbrh == df.combined$Neighborhood[i],'median']
#   df.combined[i,'LotFrontage'] <- lot.median[[1]]
# }
```

- **Fence: Fence quality**

We can replace any missing vlues for Fence and MiscFeature with 'None' as they probably don't have this feature with their property. 

```{r warning=FALSE, message=FALSE}
plot.categoric('Fence', df.combined)

df.combined$Fence[is.na(df.combined$Fence)] = 'None'


table(df.combined$MiscFeature)
df.combined$MiscFeature[is.na(df.combined$MiscFeature)] = 'None'
```

<!-- - **Fireplaces: Number of fireplaces**   -->
<!-- - **FireplaceQu: Fireplace quality ** -->

<!-- FireplaceQu denotes the fireplace quality. We can check to see if any of the missing values for FireplaceQu come from houses that recorded having at least 1 fireplace. -->

```{r warning=FALSE, message=FALSE}
# plot.categoric('FireplaceQu', df.combined)
# which((df.combined$Fireplaces > 0) & (is.na(df.combined$FireplaceQu)))
```

<!-- All the houses that have missing values did not record having any fireplaces. We can replace the NA's with 'None' since these houses don't have any fireplaces at all.  -->

```{r warning=FALSE, message=FALSE}
# df.combined$FireplaceQu[is.na(df.combined$FireplaceQu)] = 'None'
```


- **Alley: Type of alley access**

There are 2721 missing values for Alley and only 2 potential options - Grvl and Pave. We can fill 'None' for any of the houses with NA's as these houses must not have any type of alley access. 

```{r warning=FALSE, message=FALSE}
plot.categoric('Alley', df.combined)
df.combined$Alley[is.na(df.combined$Alley)] = 'None'
```

```{r warning=FALSE, message=FALSE}
paste('There are', sum(sapply(df.combined, is.na)), 'missing values left')
tr.df <- cbind(df.combined[1:1460,], train['SalePrice'])
write.csv(tr.df, file = "filled_train.csv")

```

##Adding custom numeric features

Now that we've filled in all missing values for both the training and testing sets we can split our data into a numeric set and a categoric set. Since we want our dataset to be strictly numeric values while retaining as much information as possible, we will have to transform any categoric into a binary feature using one-hot encoding. First off, we can start by adding all our numeric features to a new dataframe along with adding any extra custom made features that will help with predictive modeling.

We can start by creating a new data frame of just the numeric features

```{r warning=FALSE, message=FALSE}
num_features <- names(which(sapply(df.combined, is.numeric)))
cat_features <- names(which(sapply(df.combined, is.character)))

df.numeric <- df.combined[num_features]
```

Next we can transform any of the ordinal variables (variables that can be scaled) into numeric values. We can do this by determining which order the categories follow and assigning the values an order from 1,2,..,n. We'll group each feature by its possible values and return the median SalePrice and mean OverallQual for each unique value, then map the higher priced/better quality homes larger numeric values and the lower priced/lower quality homes smaller numeric values. 

```{r warning=FALSE, message=FALSE}
group.df <- df.combined[1:1460,]
group.df$SalePrice <- train$SalePrice
      
# function that groups a column by its features and returns the mdedian saleprice for each unique feature. 
group.prices <- function(col) {
  group.table <- group.df[,c(col, 'SalePrice', 'OverallQual')] %>%
    group_by_(col) %>%
    summarise(mean.Quality = round(mean(OverallQual),2),
      mean.Price = mean(SalePrice), n = n()) %>%
    arrange(mean.Quality)
    
  print(qplot(x=reorder(group.table[[col]], -group.table[['mean.Price']]), y=group.table[['mean.Price']]) +
    geom_bar(stat='identity', fill='cornflowerblue') +
    theme_minimal() +
    scale_y_continuous(labels = dollar) +
    labs(x=col, y='Mean SalePrice') +
    theme(axis.text.x = element_text(angle = 45)))
  
  return(data.frame(group.table))
}

## functional to compute the mean overall quality for each quality
quality.mean <- function(col) {
  group.table <- df.combined[,c(col, 'OverallQual')] %>%
    group_by_(col) %>%
    summarise(mean.qual = mean(OverallQual)) %>%
    arrange(mean.qual)
  
  return(data.frame(group.table))
}


# function that maps a categoric value to its corresponding numeric value and returns that column to the data frame
map.fcn <- function(cols, map.list, df){
  for (col in cols){
    df[col] <- as.numeric(map.list[df.combined[,col]])
  }
  return(df)
}
```

Any of the columns with the suffix 'Qual' or 'Cond' denote the quality or condition of that specific feature. Each of these columns have the potential values: `r unique(df.combined$GarageQual)`. We'll compute the mean house prices for these unique values to get a better sense of what their abbreviations mean. 

```{r warning=FALSE, message=FALSE}
qual.cols <- c('ExterQual', 'ExterCond', 'GarageQual', 'GarageCond', 'KitchenQual', 'HeatingQC', 'BsmtQual')

# group.prices('FireplaceQu')
group.prices('BsmtQual')
group.prices('KitchenQual')

```

From seeing the mean saleprices from a few of the quality and condition features we can infer that the abbreviations mean **poor**, **fair**, **typical/average**, **good** and **excelent**. We'll map numeric values from 0-5 to their corresponding categoric values (including 0 for **None**) and combine that to our dataframe.

**Note:** we will set 'None' = 0 for all categories as *None* signifies that the house does not have that particular quality/condition to rank and regardless of the houses overall quality or sale price we will keep 'None' = 0 for consistency. 

```{r warning=FALSE, mpessage=FALSE}
qual.list <- c('None' = 0, 'Po' = 1, 'Fa' = 2, 'TA' = 3, 'Gd' = 4, 'Ex' = 5)

df.numeric <- map.fcn(qual.cols, qual.list, df.numeric)
```


```{r warning=FALSE, message=FALSE}
group.prices('BsmtExposure')
bsmt.list <- c('None' = 0, 'No' = 1, 'Mn' = 2, 'Av' = 3, 'Gd' = 4)

df.numeric = map.fcn(c('BsmtExposure'), bsmt.list, df.numeric)

```

`BsmtFinType1` and `BsmtFineType2` represent the quality of the 1st and 2nd finished areas. There should be some order between the different types of qualities, we'll see if we can find a similarity between the 2 features.

```{r warning=FALSE, message=FALSE}
group.prices('BsmtFinType1')
```

- **BsmtFinType1: Quality of basement finished area**  
- **BsmtFinSF1: Type 1 finished square feet**  

Here returning the mean sale prices might not be as helpful as computing the median basement areas for both columns to determine which quality is better than the other. 

```{r warning=FALSE, message=FALSE}
# visualization for BsmtFinTyp2 instead of another table
df.combined[,c('BsmtFinType1', 'BsmtFinSF1')] %>%
  group_by(BsmtFinType1) %>%
  summarise(medianArea = median(BsmtFinSF1), counts = n()) %>%
  arrange(medianArea) %>%
  ggplot(aes(x=reorder(BsmtFinType1,-medianArea), y=medianArea)) +
  geom_bar(stat = 'identity', fill='cornflowerblue') +
  labs(x='BsmtFinType2', y='Median of BsmtFinSF2') +
  geom_text(aes(label = sort(medianArea)), vjust = -0.5) +
  scale_y_continuous(limits = c(0,850)) +
  theme_minimal()
```

Through investigating the relationships between the basement quality and areas we an see the true order of qualities of each basement to be *'None' < 'Unf' < 'LwQ' < 'BLQ' < 'Rec' < 'ALQ' < 'GLQ'*. 

```{r warning=FALSE, message=FALSE}
bsmt.fin.list <- c('None' = 0, 'Unf' = 1, 'LwQ' = 2,'Rec'= 3, 'BLQ' = 4, 'ALQ' = 5, 'GLQ' = 6)
df.numeric <- map.fcn(c('BsmtFinType1','BsmtFinType2'), bsmt.fin.list, df.numeric)
```

- **Functional: Home functionality rating**

This feature doesn't really tell us much and functionality is very vague to tie which other features have a correlation with it. We can compute the mean sale prices for each functional category and assign numeric values accordingly.

```{r warning=FALSE, message=FALSE}
group.prices('Functional')
functional.list <- c('None' = 0, 'Sal' = 1, 'Sev' = 2, 'Maj2' = 3, 'Maj1' = 4, 'Mod' = 5, 'Min2' = 6, 'Min1' = 7, 'Typ'= 8)

df.numeric['Functional'] <- as.numeric(functional.list[df.combined$Functional])
```

We'll continue to do the same for GarageFinish and Fence:

```{r warning=FALSE, message=FALSE}
group.prices('GarageFinish')
garage.fin.list <- c('None' = 0,'Unf' = 1, 'RFn' = 1, 'Fin' = 2)

df.numeric['GarageFinish'] <- as.numeric(garage.fin.list[df.combined$GarageFinish])


group.prices('Fence')
fence.list <- c('None' = 0, 'MnWw' = 1, 'GdWo' = 1, 'MnPrv' = 2, 'GdPrv' = 4)

df.numeric['Fence'] <- as.numeric(fence.list[df.combined$Fence])

MSdwelling.list <- c('20' = 1, '30'= 0, '40' = 0, '45' = 0,'50' = 0, '60' = 1, '70' = 0, '75' = 0, '80' = 0, '85' = 0, '90' = 0, '120' = 1, '150' = 0, '160' = 0, '180' = 0, '190' = 0)

df.numeric['NewerDwelling'] <- as.numeric(MSdwelling.list[as.character(df.combined$MSSubClass)])

      
```

We've transformed all the categoric features with an ordianl scale into a numeric columns. Let's see which variables have the strongest effect on a houses sale price. 

To determine which features have the strongest relationship with **SalePrice** we can compute the sample correlation coefficient between the 2 variables, $$r_{xy} = \frac{s_{xy}}{s_xs_y}$$ where $s_{xy} = \mathbf{E}[(X-\mathbf{E}[X])(Y-\mathbf{E}[Y])$ is the sample covariance and $s_x, s_y$ are the sample standard deviations. The correlation coefficient measures the how linearly related the 2 variables are. A coefficient of 0 means that the 2 variables show no linear relationship, a coefficient between (0,1] shows that they have positive relationship and a coefficient between [-1,0) means they have a negative relationship. We're particularly interested in variables that show strong relationship with **SalePrice** so we will focus primarily on features that have a coefficient > .5 or < -.5. 

```{r}
# need the SalePrice column
corr.df <- cbind(df.numeric[1:1460,], train['SalePrice'])

# only using the first 1460 rows - training data
correlations <- cor(corr.df)
# only want the columns that show strong correlations with SalePrice
corr.SalePrice <- as.matrix(sort(correlations[,'SalePrice'], decreasing = TRUE))

corr.idx <- names(which(apply(corr.SalePrice, 1, function(x) (x > 0.5 | x < -0.5))))

# corrplot(as.matrix(correlations[corr.idx,corr.idx]), type = 'upper', method='color', addCoef.col = 'black', tl.cex = .7,cl.cex = .7, number.cex=.7)
```

From the correlation plot we can see the 10 features with the strongest effect on SalePrice.   

 - **OverallQual: Overall material and finish quality**  
 - **GrLivArea: Above grade (ground) living area square feet**  
These 2 features have the highest correlation and very reasonably make sense.

- **GarageCars: Size of garage in car capacity**  
- **GarageArea: Size of garage in square feet**  
These 2 features from our plot are the next best thing, however, this might not have been something we expected. We can also see that the correlation between the 2 is extremely high, 0.88, which makes sense as the area of the garage is a constraint on how many cars can fit. 

- **TotalBsmtSF: Total square feet of basement area**  
- **1stFlrSF: First Floor square feet**  
These features also make intuitive sense as anything corresponding to area/size of the house will have an effect on the price. We can also see that these 2 features have a strong linear relationship with one another, which makes sense as the size of the basement can certainly depend on the size of the houses 1st floor. 

**FullBath: Full bathrooms above grade**  
**TotRmsAbvGrd: Total rooms above grade (does not include bathrooms)**  
Something we might have expected as well is that the number of rooms in the house having a relationship with the houses price. We can further see that the strong correlation between **GrLivArea** and **TotRmsAbvGrd** since the size of the livign area will most likely be a contstraint on the number of rooms above ground. An interesting relationship we might want to look into are the relationship between houses with a small living area but many rooms, which will result in smaller rooms and vise versa. We may want to check to see if this is an indicator on higher/lower house prices. 

**YearBuilt: Original construction date**  
**YearRemodAdd: Remodel date**  
A positive correlation for both of these is not something we should be surprised by. The newer homes will likely give higher listings compared to older models. 

We can print a matrix of scatter plots to see what these relationships look like under the hood to get a better sense of whats going on. 

```{r warning=FALSE, message=FALSE}
require(GGally)
lm.plt <- function(data, mapping, ...){
   plt <- ggplot(data = data, mapping = mapping) + 
    geom_point(shape = 20, alpha = 0.7, color = 'darkseagreen') +
    geom_smooth(method=loess, fill="red", color="red") +
    geom_smooth(method=lm, fill="blue", color="blue") +
    theme_minimal()
  return(plt)
}

ggpairs(corr.df, corr.idx[1:6], lower = list(continuous = lm.plt))
```

The blue lines in the scatter plots represent a simple linear regression fit while the red lines represent a local polynomial fit. We can see both OverallQual and GrLivArea and TotalBsmtSF follow a linear model, but have some outliers we may want to look into. For instance, there are multiple houses with an overall quality of 10, but have suspisciously low prices. We can see similar behavior in GrLivArea and TotalBsmtSF. GarageCars and GarageArea both follow more of a quadratic fit. It seems that having a 4 car garage does not result in a higher house price and same with an extremely large area. 

```{r warning=FALSE, message=FALSE}
ggpairs(corr.df, corr.idx[c(1,7:11)], lower = list(continuous = lm.plt))
```

More of the same with the remaining features with 1stFlrSF, FullBath, TotRmsAbvGrd following linear model while YearBuilt and YearRemodAdd both having non-linear/quadratic models. Taking a closer look to YearBuilt and YearRemodAdd we can see that the most expensive homes are the most recently built and remodelled. 


Now for some of the nominal variables we can take one of the categories that is distict from the others and create a binary feature that returns 1 if the house has that specific value and 0 if it does not.

```{r warning=FALSE, message=FALSE}
plot.categoric('LotShape', df.combined)
```

LotShape has 3 values for having an irregular shape and only 1 for regular. We can create a binary column that returns 1 for houses with a regular lot shape and 0 for houses with any of the 3 irregular lot shapes. Using this method of turning a categoric feature into a binary column will ultimately  help our data train better through boosted models without using numeric placeholders on nominal data. 

```{r warning=FALSE, message=FALSE}
df.numeric['RegularLotShape'] <- (df.combined$LotShape == 'Reg') * 1
```

We'll use this exact same method for:

**LandContour: Flatness of the property**  
**LandSlope: Slope of property**  
**Electrical: Electrical system**  
**GarageType: Garage location**  
**PavedDrive: Paved driveway**  
**MiscFeature: Miscellaneous feature not covered in other categories** 

```{r warning=FALSE, message=FALSE}
plot.categoric('LandContour', df.combined)

df.numeric['LandLeveled'] <- (df.combined$LandContour == 'Lvl') * 1

plot.categoric('LandSlope', df.combined)

df.numeric['LandSlopeGentle'] <- (df.combined$LandSlope == 'Gtl') * 1

plot.categoric('Electrical', df.combined)

df.numeric['ElectricalSB'] <- (df.combined$Electrical == 'SBrkr') * 1

plot.categoric('GarageType', df.combined)

df.numeric['GarageDetchd'] <- (df.combined$GarageType == 'Detchd') * 1

plot.categoric('PavedDrive', df.combined)

df.numeric['HasPavedDrive'] <- (df.combined$PavedDrive == 'Y') * 1

df.numeric['HasWoodDeck'] <- (df.combined$WoodDeckSF > 0) * 1

df.numeric['Has2ndFlr'] <- (df.combined$X2ndFlrSF > 0) * 1

df.numeric['HasMasVnr'] <- (df.combined$MasVnrArea > 0) * 1
```

```{r warning=FALSE, message=FALSE}
plot.categoric('MiscFeature', df.combined)
```

For `MiscFeature` the only feature with a significant amount of houses having it is *Shed*. We can one-hot encode houses that have Sheds vs those who do not. 

```{r warning=FALSE, message=FALSE}
df.numeric['HasShed'] <- (df.combined$MiscFeature == 'Shed') * 1
```

**YearBuilt: Original construction date**  
**YearRemodAdd: Remodel date**  

Many of the houses recorded the same year for `YearBuilt` and `YearRemodAdd`. We can create a new column that records that a house was remodelled if the year it was built is different than the remodel year. This 

```{r warning=FALSE, message=FALSE}
df.numeric['Remodeled'] <- (df.combined$YearBuilt != df.combined$YearRemodAdd) * 1
```

We can also create a column that seperates which houses have been recently remodelled vs those who are not. Houses that have been remodelled after the year they were sold will fall into this category. 

```{r warning=FALSE, message=FALSE}
df.numeric['RecentRemodel'] <- (df.combined$YearRemodAdd >= df.combined$YrSold) * 1
```

There can be potential value to homes who were sold the same year they were built as this could be an indicator that these houses were hot in the market. 

```{r warning=FALSE, message=FALSE}
df.numeric['NewHouse'] <- (df.combined$YearBuilt == df.combined$YrSold) * 1
```

What about the houses with area based features equal to 0? Houses with 0 square footage for a columnshows that the house does not have that feature at all. We add a one-hot encoded column for returning 1 for any house with an area greater than 0 since this means that the house *does* have this feature and 0 for those who do not! 

```{r warning=FALSE, message=FALSE}
#cols.binary <- c('X2ndFlrSF', 'MasVnrArea', 'WoodDeckSF')
cols.binary <- c('X2ndFlrSF', 'MasVnrArea', 'WoodDeckSF', 'OpenPorchSF', 'EnclosedPorch', 'X3SsnPorch', 'ScreenPorch')

for (col in cols.binary){
  df.numeric[str_c('Has',col)] <- (df.combined[,col] != 0) * 1
}
```

We know how important the year a house was built and sold but what about what the specific month it was sold? How do houses sold during summer compare to the other seasons? 

```{r warning=FALSE, message=FALSE}
ggplot(df.combined, aes(x=MoSold)) +
  geom_bar(fill = 'cornflowerblue') +
  geom_text(aes(label=..count..), stat='count', vjust = -.5) +
  theme_minimal() +
  scale_x_continuous(breaks = 1:12)
```

The largest proportion of houses sold is during the summer months: May, June, July. Let's add a column that seperates the the summer houses from the rest. 

```{r warning=FALSE, message=FALSE}
df.numeric['HighSeason'] <- (df.combined$MoSold %in% c(5,6,7)) * 1
```

What about which Neighborhoods are more expensive than others? 

```{r warning=FALSE, message=FALSE, results=FALSE}
train[,c('Neighborhood','SalePrice')] %>%
  group_by(Neighborhood) %>%
  summarise(median.price = median(SalePrice, na.rm = TRUE)) %>%
  arrange(median.price) %>%
  mutate(nhbr.sorted = factor(Neighborhood, levels=Neighborhood)) %>%
  ggplot(aes(x=nhbr.sorted, y=median.price)) +
  geom_point() +
  geom_text(aes(label = median.price, angle = 45), vjust = 2) +
  theme_minimal() +
  labs(x='Neighborhood', y='Median price') +
  theme(text = element_text(size=12),
        axis.text.x = element_text(angle=45))
```


StoneBr, NoRidge, NridgHt have a large gap between them versus the rest of the median prices from any of the other neighborhods. It would be wise of us to check if this is from outliers or if these houses are much pricier as a whole. 

```{r warning=FALSE, message=FALSE}
other.nbrh <- unique(df.combined$Neighborhood)[!unique(df.combined$Neighborhood) %in% c('StoneBr', 'NoRidge','NridgHt')]

ggplot(train, aes(x=SalePrice, y=GrLivArea, colour=Neighborhood)) +
  geom_point(shape=16, alpha=.8, size=4) +
  scale_color_manual(limits = c(other.nbrh, 'StoneBr', 'NoRidge', 'NridgHt'), values = c(rep('black', length(other.nbrh)), 'indianred',
                                    'cornflowerblue', 'darkseagreen')) +
  theme_minimal() +
  scale_x_continuous(label=dollar)
```

3 houses from StoneBr, NoRidge and NridgHt with house prices over $500,000 which no other Neighborhood is in the same range. What pops out even more in this plot is the 2 houses with an enormous GrLivArea of over 4500 square ft yet very low sale prices. We certianly have an opportunity to explore these outliers in depth, we'll take a look at this later. 

In the mean time lets one-hot encode the more expensive neighborhoods and add that to our dataframe

```{r warnings=FALSE, message=FALSE}
nbrh.rich <- c('Crawfor', 'Somerst, Timber', 'StoneBr', 'NoRidge', 'NridgeHt')
df.numeric['NbrhRich'] <- (df.combined$Neighborhood %in% nbrh.rich) *1
```

How about a numeric mapping to the neighborhoods who have higher quality homes and run for larger sale prices?

```{r}
group.prices('Neighborhood')

nbrh.map <- c('MeadowV' = 0, 'IDOTRR' = 1, 'Sawyer' = 1, 'BrDale' = 1, 'OldTown' = 1, 'Edwards' = 1, 
             'BrkSide' = 1, 'Blueste' = 1, 'SWISU' = 2, 'NAmes' = 2, 'NPkVill' = 2, 'Mitchel' = 2,
             'SawyerW' = 2, 'Gilbert' = 2, 'NWAmes' = 2, 'Blmngtn' = 2, 'CollgCr' = 2, 'ClearCr' = 3, 
             'Crawfor' = 3, 'Veenker' = 3, 'Somerst' = 3, 'Timber' = 3, 'StoneBr' = 4, 'NoRidge' = 4, 
             'NridgHt' = 4)

df.numeric['NeighborhoodBin'] <- as.numeric(nbrh.map[df.combined$Neighborhood])
```

**SaleCondition:** Condition of sale

```{r warning=FALSE, message=FALSE}
group.prices('SaleCondition')
```

Tried to do some research to get a sense of what the terms mean for SaleCondition but couldn't find much. The houses with 'Partial' for SaleCondition have both the highest quality and highest sale price well above the other qualities. Instead of mapping each quality to its own numeric value we can one hot encode for houses with *Partial*

```{r warning=FALSE, message=FALSE}
df.numeric['PartialPlan'] <- (df.combined$SaleCondition == 'Partial') * 1

group.prices('HeatingQC')

heating.list <- c('Po' = 0, 'Fa' = 1, 'TA' = 2, 'Gd' = 3, 'Ex' = 4)

df.numeric['HeatingScale'] <- as.numeric(heating.list[df.combined$HeatingQC])
```


**1stFlrSF:** First Floor square feet  
**2ndFlrSF:** Second floor square feet  
**LowQualFinSF:** Low quality finished square feet (all floors)  
1stFlrSF + 2nFlrSF + LowQualFinSF = GrLivArea. 

```{r warning=FALSE, message=FALSE}
area.cols <- c( 'LotArea', 'MasVnrArea', 'BsmtFinSF1', 'BsmtFinSF2', 'BsmtUnfSF',
             'TotalBsmtSF', 'X1stFlrSF', 'X2ndFlrSF', 'GrLivArea', 'GarageArea', 'WoodDeckSF', 
             'OpenPorchSF', 'EnclosedPorch', 'X3SsnPorch', 'ScreenPorch', 'LowQualFinSF', 'PoolArea')

df.numeric['TotalArea'] <- as.numeric(rowSums(df.combined[,area.cols]))

#paste('There are', sum((df.combined$X1stFlrSF + df.combined$X2ndFlrSF) != df.combined$GrLivArea), 'houses with LowQualFinSF > 0')
```


```{r warning=FALSE, message=FALSE}
df.numeric['AreaInside'] <- as.numeric(df.combined$X1stFlrSF + df.combined$X2ndFlrSF)
```

We've seen how strong of an effect the year of a house built has on the house price, therefore, as this dataset collects houses up until 2010 we can determine how old a house is and how long ago the house was sold:

```{r warning=FALSE, message=FALSE}
df.numeric['Age'] <- as.numeric(2010 - df.combined$YearBuilt)

df.numeric['TimeSinceSold'] <- as.numeric(2010 - df.combined$YrSold)

# how many years since the house was remodelled and sold 
df.numeric['YearSinceRemodel'] <- as.numeric(df.combined$YrSold - df.combined$YearRemodAdd)
```

Correlation plot with OverallQual
```{r warnings=FALSE, message=FALSE}
corr.OverallQual <- as.matrix(sort(correlations[,'OverallQual'], decreasing = TRUE))

corr.idx <- names(which(apply(corr.OverallQual, 1, function(x) (x > 0.5 | x < -0.5))))
# 
# corrplot(as.matrix(correlations[corr.idx, corr.idx]), type = 'upper',
#          method = 'color', addCoef.col = 'black', tl.cex =.7, cl.cex = .7,
#          number.cex = .7)
```

##Outliers

Earlier we saw some suspicious houses with abnormally large GrLivArea's, 2 of which had very low SalePrices. These outliers may disrupt our ability to accurately predict. Lets take a closer look at these values and see if we may want to remove them

```{r warning=FALSE, message=FALSE}
tr<-train
train.test.df <- rbind(dplyr::select(train,-SalePrice), test)
train.test.df$type <- c(rep('train',1460),rep('test',1459))

ggplot(train, aes(x=GrLivArea)) +
  geom_histogram(fill='lightblue',color='white') +
  theme_minimal()

outlier_values <- boxplot.stats(train$GrLivArea)$out  # outlier values.
boxplot(train$GrLivArea, main="GrLivArea", boxwex=0.1)
mtext(paste("Outliers: ", paste(outlier_values[outlier_values>4000], collapse=", ")), cex=0.6)

ggplot(train.test.df, aes(x=type, y=GrLivArea, fill=type)) +
  geom_boxplot() +
  theme_minimal() +
  scale_fill_manual(breaks = c("test", "train"), values = c("indianred", "lightgreen"))

ggplot(tr, aes(x=GrLivArea, y=SalePrice)) +
  geom_point(color="indianred")
```

For the training data we can see 4 houses whose GrLivArea is greater than 4000 yet there is one in the testing set. While it is always a great option to remove outliers from our data as they are usually telling us something more than meets the eye about what is going on with the data, these houses in the trainng set are obnoxiously large and ultimately do not add much value and are causing heavy skewness in both the SalePrice and GrLivArea and particularly the 2 values that have above a 4000 GrLivArea but low SalePrice are putting a constraint on the correlation between the 2 variables. Lets throw these houses out of training set begin preprocessing our data now that there are no heavy outliers. 

```{r warning=FALSE, message=FALSE}
idx.outliers <- which(train$GrLivArea > 4000)
df.numeric <- df.numeric[!1:nrow(df.numeric) %in% idx.outliers,]
df.combined <- df.combined[!1:nrow(df.combined) %in% idx.outliers,]
dim(df.numeric)
```
##Preprocessing

If we want to use any type of linear regression model an important assumption we need to check is for normality in any of the dependant variables. We can use a Kolmogorov-Smirnof test or compute the skewness/kurtosis in each column to verify normality. A Kolmogorov-Smirnof test compares the sample distribution to a normal and returns a p-value determining if the the 2 distributions are similar. Skewness is a measure of symmetry where distributions with 0 skew follow a normal shape. Kurtosis measures the taildness of the distribution. For skewnesses outside the range of -0.8 to 0.8 and kurtosises outside the of -3.0 to 3.0 do not satisfy the assumption of normality  For any features that are not normally distributed we can make a non-linear transformation like a log-transformation such that $f(x)=log(x+1)$ when a column has 0 and $f(x)=log(x)$ when there are no 0's in the column. We do this because $log(0)=-\infty$. We will also scale all of the numeric data by standardizing the data (opposed to normalizing) as we know our data has potential outliers we don't want to bound each column. To standardize the observations at indivisual column we compute $$z_{ij} = \frac{x_{ij}-\bar{x_j}}{s_j}$$ where $\bar{x_j}$ is the sample mean at column *j* and $s_j$ is the sample deviation at column *j*. 

```{r warning=FALSE, message=FALSE}
require(psych)
# linear models assume normality from dependant variables 
# transform any skewed data into normal
skewed <- apply(df.numeric, 2, skewness)
skewed <- skewed[(skewed > 0.8) | (skewed < -0.8)]

kurtosis <- apply(df.numeric, 2, kurtosi)
kurtosis <- kurtosis[(kurtosis > 3.0) | (kurtosis < -3.0)]

# not very useful in our case
ks.p.val <- NULL
for (i in 1:length(df.numeric)) {
  test.stat <- ks.test(df.numeric[i], rnorm(1000))
  ks.p.val[i] <- test.stat$p.value
}

for(col in names(skewed)){
  if(0 %in% df.numeric[, col]) {
    df.numeric[,col] <- log(1+df.numeric[,col])
  }
  else {
    df.numeric[,col] <- log(df.numeric[,col])
  }
}

# normalize the data
scaler <- preProcess(df.numeric)
df.numeric <- predict(scaler, df.numeric)

```

For the rest of the categoric features we can one-hot encode each value to get as many splits in the data as possible  

```{r warning=FALSE, message=FALSE}
# one hot encoding for categorical data
# sparse data performs better for trees/xgboost
dummy <- dummyVars(" ~ .",data=df.combined[,cat_features])
df.categoric <- data.frame(predict(dummy,newdata=df.combined[,cat_features]))
```

What about YearBuilt, GarageYrBlt and YearRemodAdd?

YearBuilt had a correlation coefficient of 0.57 with SalePrice, GarageYrBlt had a coefficiient of 0.56 and YearRemodAdd had scored a 0.55. Knowing how important these features are we want to make as much use with them as possible. The houses in our data start from 1871 and were built up until 2010. We can bin houses into sequences of 20, which will give us 7 different bins for a feature built in a year to fall into. This will allow us to differentiate the different times/era houses, garages and remodeling took place. 

```{r warning=FALSE, message=FALSE}
# every 20 years create a new bin
# 7 total bins
# min year is 1871, max year is 2010!
year.map = function(col.combined, col.name) {
  for (i in 1:7) {
    year.seq = seq(1871+(i-1)*20, 1871+i*20-1)
    idx = which(df.combined[,col.combined] %in% year.seq)
    df.categoric[idx,col.name] = i
  }
  return(df.categoric)
}

```

```{r warning=FALSE, message=FALSE}
# we'll c
df.categoric['GarageYrBltBin'] = 0
df.categoric <- year.map('GarageYrBlt', 'GarageYrBltBin')
df.categoric['YearBuiltBin'] = 0
df.categoric <- year.map('YearBuilt','YearBuiltBin')
df.categoric['YearRemodAddBin'] = 0
df.categoric <- year.map('YearRemodAdd', 'YearRemodAddBin')
```

Now that we 3 new columns that generalize what year a house, garage and remodeling took place we'll need to one-hot encode these columns so that each bin is turned into a binary column. The new columns are ranged from 1-7, but we don't know what specific order they follow so it will benefit us more to give each bin its own column. 

```{r warning=FALSE, message=FALSE}
bin.cols <- c('GarageYrBltBin', 'YearBuiltBin', 'YearRemodAddBin')

for (col in bin.cols) {
  df.categoric <- cbind(df.categoric, model.matrix(~.-1, df.categoric[col]))
}

# lets drop the orginal 'GarageYrBltBin', 'YearBuiltBin', 'YearRemodAddBin' from our dataframe
df.categoric <- df.categoric[,!names(df.categoric) %in% bin.cols]
```

We're finally done clearning, manipulating and adding features to our data. We'll combine the numeric and categoric dataframes into one, which we will use to build or models on. 

```{r warning=FALSE, message=FALSE}
df <- cbind(df.numeric, df.categoric)
```

What does our distribution of housing prices look like?

```{r warning=FALSE, message=FALSE}
require(WVPlots)
y.true <- train$SalePrice[which(!1:1460 %in% idx.outliers)]

qplot(y.true, geom='density') +# +(train, aes(x=SalePrice)) +
  geom_histogram(aes(y=..density..), color='white', 
                 fill='lightblue', alpha=.5, bins = 60) +
  geom_line(aes(y=..density..), color='cornflowerblue', lwd = 1, stat = 'density') + 
  stat_function(fun = dnorm, colour = 'indianred', lwd = 1, args = 
                  list(mean(train$SalePrice), sd(train$SalePrice))) +
  scale_x_continuous(breaks = seq(0,800000,100000), labels = dollar) +
  scale_y_continuous(labels = comma) +
  theme_minimal() +
  annotate('text', label = paste('skewness =', signif(skewness(train$SalePrice),4)),
           x=500000,y=7.5e-06)

qqnorm(train$SalePrice)
qqline(train$SalePrice)
```

We can see from the histogram and the quantile-quantile plot that the distribution of sale prices is right-skewed and does not follow a normal distribution. Lets make a log-transformation and see how our data looks

```{r warning=FALSE, message=FALSE}
y_train <- log(y.true+1)

qplot(y_train, geom = 'density') +
  geom_histogram(aes(y=..density..), color = 'white', fill = 'lightblue', alpha = .5, bins = 60) +
  scale_x_continuous(breaks = seq(0,800000,100000), labels = comma) +
  geom_line(aes(y=..density..), color='dodgerblue4', lwd = 1, stat = 'density') + 
  stat_function(fun = dnorm, colour = 'indianred', lwd = 1, args = 
                  list(mean(y_train), sd(y_train))) +
  #scale_x_continuous(breaks = seq(0,800000,100000), labels = dollar) +
  scale_y_continuous(labels = comma) +
  theme_minimal() +
  annotate('text', label = paste('skewness =', signif(skewness(y_train),4)),
           x=13,y=1) +
  labs(x = 'log(SalePrice + 1)') 

qqnorm(y_train)
qqline(y_train)
```

```{r}
paste('The dataframe has', dim(df)[1], 'rows and', dim(df)[2], 'columns')
```

We've manipulated a lot of variables and added many features, 345 to be exact, in our dataset and their could potentially be some variables that won't give our data any value when we're modeling. Some of these features may have become zero-variance predictors, such that a few samples may have an insignificant influence on the model. These *near-zero-variance* may cause overfitting or will prevent our model from generalizing over the data at a more sufficient rate. The package `caret` offers a function `nearZeroVar`, which checks the frequency of the most common value over the second most frequent value, which would be closer to 1 for well-behaved predictors and very large for highly-unbalanced features. It also checks the number of unique values divided by the *n* number of samples which will approach zero as the level of detail in the feature increases. We can remove all of the near-zero-variance variables from out dataframe.

```{r warning=FALSE, message=FALSE}
nzv.data <- nearZeroVar(df, saveMetrics = TRUE)

# take any of the near-zero-variance perdictors
drop.cols <- rownames(nzv.data)[nzv.data$nzv == TRUE]

df <- df[,!names(df) %in% drop.cols]

paste('The dataframe now has', dim(df)[1], 'rows and', dim(df)[2], 'columns')
```


Our new distribution with the transformed data follows much closer to a normal distribution and we can verify this from the quantile-quantile plot. Now that our independent and dependent variables satisfy the assumption of normality we can begin building our model.
```{r warning=FALSE, message=FALSE}
xall_train <- df[1:1456,]

xall_test <- df[1457:nrow(df),]
```

```{r}
xtall_train<-xall_train
xtall_train['SalePrice']<-y_train
# Multiple Linear Regression using all predictors
lmFitAllPredictors = lm(SalePrice~.,data = xtall_train)
summary(lmFitAllPredictors)
# Residual standard error: 0.1051 on 1322 degrees of freedom
# Multiple R-squared:  0.9361,	Adjusted R-squared:  0.9296 
# F-statistic: 145.5 on 133 and 1322 DF,  p-value: < 2.2e-16

AIC(lmFitAllPredictors, k=2)
BIC(lmFitAllPredictors)
# [1] -2299.759
# [1] -1586.493

lmPred1 <- predict(lmFitAllPredictors, xall_test)
# lmPred1_n<-as.numeric(predict(lmFitAllPredictors, xall_test))
head(lmPred1)
lmPred1_pred <- as.double(exp(lmPred1) - 1)
write.csv(lmPred1_pred, file = "lmPred1_pred.csv")
```

```{r}
# Multiple Linear Regression using filtered predictors
tooHigh <- findCorrelation(cor(df), .9)
fil_df<-df[, -tooHigh]
x_train <- fil_df[1:1456,]

x_test <- fil_df[1457:nrow(df),]
xt_train<-x_train
xt_train['SalePrice']<-y_train

lmFitfilteredPredictors = lm(SalePrice~.,data = xt_train)
summary(lmFitfilteredPredictors)
# Residual standard error: 0.1068 on 1340 degrees of freedom
# Multiple R-squared:  0.933,	Adjusted R-squared:  0.9273 
# F-statistic: 162.3 on 115 and 1340 DF,  p-value: < 2.2e-16
AIC(lmFitfilteredPredictors, k=2)
BIC(lmFitfilteredPredictors)
# [1] -2268.266
# [1] -1650.103
lmPred1 <- predict(lmFitfilteredPredictors, x_test)
# lmPred1_n<-as.numeric(predict(lmFitfilteredPredictors, x_test))
head(lmPred1)
lmPred1_pred <- as.double(exp(lmPred1) - 1)
write.csv(lmPred1_pred, file = "lmPred1_pred.csv")
```

```{r}
# Linear regression model with 10 folds CV
ctrl <- trainControl(method = "cv", number = 10)
set.seed(100)
lmFit1 <- train(x = x_train, y = y_train, method = "lm", trControl = ctrl)

summary(lmFit1)
# Residual standard error: 0.1068 on 1340 degrees of freedom
# Multiple R-squared:  0.933,	Adjusted R-squared:  0.9273 
# F-statistic: 162.3 on 115 and 1340 DF,  p-value: < 2.2e-16
apply(lmFit1$resample[,1:2],2,sd)
#       RMSE   Rsquared 
# 0.01434768 0.01812518 
lmFit1_pred<-predict(lmFit1, x_test)
# lmFit1_pred_n<-as.numeric(predict(lmFit1, x_test))
lmFit1_pred_1 <- as.double(exp(lmFit1_pred) - 1)
write.csv(lmFit1_pred_1, file = "lmFit1_pred.csv")

xyplot(y_train ~ predict(lmFit1),
  type = c("p", "g"),
  xlab = "Predicted", ylab = "Observed")
xyplot(resid(lmFit1) ~ predict(lmFit1),
       type = c("p", "g"),
       xlab = "Predicted", ylab = "Residuals")
```

```{r}
# Robust linear regresson with 10 folds CV
set.seed(100)
rlmPCA <- train(x_train, y_train,
                method = "rlm",
                preProcess = "pca",
                trControl = ctrl)
rlmPCA
summary(rlmPCA)
# intercept  psi           RMSE        Rsquared   MAE        
#    TRUE      psi.huber      0.1209279  0.9076801   0.08534104
rlmPCA_pred<-predict(rlmPCA, x_test)
# rlmPCA_pred_n<-as.numeric(predict(rlmPCA, x_test))
rlmPCA_pred_1 <- as.double(exp(rlmPCA_pred) - 1)
write.csv(rlmPCA_pred_1, file = "rlmPCA_pred.csv")
apply(rlmPCA$resample[,1:2],2,sd)
#       RMSE   Rsquared 
# 0.01556433 0.02063341 
```

```{r}
# Partial Least Squares (PLS) with 10 folds CV
set.seed(100)
require(pls)
plsTune <- train(x_train, y_train,
                 method = "pls",
                 tuneLength = 20,
                 trControl = ctrl,
                 preProc = c("center", "scale"))
plsTune
summary(plsTune)
# ncomp  RMSE       Rsquared   MAE       
#   20     0.1132457  0.9184889  0.07858579
plsTune_pred<-predict(plsTune, x_test)
plsTune_pred_n<-as.numeric(predict(plsTune, x_test))
plsTune_pred_1 <- as.double(exp(plsTune_pred) - 1)
write.csv(plsTune_pred_1, file = "plsTune_pred.csv")
varImp(plsTune,scale = FALSE)
apply(plsTune$resample[,1:2],2,sd)
# RMSE   Rsquared 
# 0.01414828 0.01785560 
```

```{r}
# Principal Component Regression (PCR) with 10 folds CV
set.seed(100)
pcrTune <- train(x = x_train, y = y_train, method = "pcr", tuneGrid = expand.grid(ncomp = 1:35), trControl = ctrl)
pcrTune  
summary(pcrTune)
# ncomp  RMSE       Rsquared   MAE 
# 35     0.1214349  0.9067512  0.08715017
pcrTune_pred<-predict(pcrTune, x_test)
# pcrTune_pred_n<-as.numeric(predict(pcrTune, x_test))
pcrTune_pred_1 <- as.double(exp(pcrTune_pred) - 1)
write.csv(pcrTune_pred_1, file = "pcrTune_pred.csv")
apply(pcrTune$resample[,1:2],2,sd)
#      RMSE   Rsquared 
# 0.01359602 0.01822849 
```

```{r}
# Ridge regression
require(elasticnet)

ridgeGrid <- data.frame(.lambda = seq(0, .1, length = 15))
set.seed(100)
ridgeRegFit <- train(x_train, y_train,
                     method = "ridge",
                     tuneGrid = ridgeGrid,
                     trControl = ctrl,
                     preProc = c("center", "scale"))
ridgeRegFit
summary(ridgeRegFit)
# lambda       RMSE       Rsquared   MAE       
#   0.014285714  0.1129433  0.9192039  0.07891216
ridgeRegFit_pred<-predict(ridgeRegFit, x_test)
# ridgeRegFit_pred_n<-as.numeric(predict(ridgeRegFit, x_test))
ridgeRegFit_pred_1 <- as.double(exp(ridgeRegFit_pred) - 1)
write.csv(ridgeRegFit_pred_1, file = "ridgeRegFit_pred.csv")
apply(ridgeRegFit$resample[,1:2],2,sd)
# RMSE   Rsquared 
# 0.01403201 0.01789303 
```

```{r}
#Elastic Net
enetGrid <- expand.grid(.lambda = c(0, 0.01, .1),
                          .fraction = seq(.05, 1, length = 20))
set.seed(100)
enetTune <- train(x_train, y_train,
                    method = "enet",
                    tuneGrid = enetGrid,
                    trControl = ctrl,
                    preProc = c("center", "scale"))
enetTune
summary(enetTune)
# lambda  fraction  RMSE          Rsquared   MAE 
# 0.10    0.60      0.1170720  0.9145279  0.08440295
enetTune_pred<-predict(enetTune, x_test)
enetTune_pred_n <- as.numeric(predict(enetTune, x_test))
enetTune_pred_1 <- as.double(exp(enetTune_pred) - 1)
write.csv(enetTune_pred_1, file = "enetTune_pred.csv")
apply(enetTune$resample[,1:2],2,sd)
# RMSE   Rsquared 
# 0.01412760 0.01714102
plot(enetTune)

#Ensemble of PLS Tune with 10 fold CV and Enet with 10 fold CV 

ensem_pred <- (plsTune_pred_n + enetTune_pred_n)/2.0

# ensem_pred <- (ridgeRegFit_pred_n + enetTune_pred_n)/2.0 
ensem_pred_1 <- as.double(exp(ensem_pred) - 1)
write.csv(ensem_pred_1, file = "ensem_pred.csv")
```

```{r}
## Build a simple regression tree
# install.packages("gbm")
# library(gbm)
# install.packages("ipred")
# library(ipred)
# install.packages("party")
# library(party)
# install.packages("partykit")
# library(partykit)
# install.packages("randomForest")
# library(randomForest)
require(gbm)
require(ipred)
require(party)
require(partykit)
require(randomForest)
require(rpart)
rPartModel = rpart( SalePrice~.,data = xt_train, method="anova", control=rpart.control(cp=0.01,maxdepth=6) ) 
rpartTree = as.party(rPartModel)
dev.new()
plot(rpartTree)
rPart_yHat = predict(rPartModel,x_test)
rPart_yHat_pred_1 <- as.double(exp(rPart_yHat) - 1)
write.csv(rPart_yHat_pred_1, file = "rPart_yHat_pred.csv")
summary(rPartModel)
# Node number 19: 331 observations
#   mean=11.83108, MSE=0.02666629 
## Bagged tree:
BaggTree= bagging( SalePrice~.,data = xt_train)

# predict solubility with this regression tree: 
Bagg_yHat = predict(BaggTree,x_test)
Bagg_yHat_pred_1 <- as.double(exp(Bagg_yHat) - 1)
write.csv(Bagg_yHat_pred_1, file = "Bagg_yHat_pred.csv")
summary(BaggTree)


# fit a randomforest:
rfModel = randomForest( SalePrice~.,data = xt_train, ntree=500 ) # ntree=500
summary(rfModel)
# predict solubility:
rf_yHat = predict(rfModel,x_test)
rf_yHat_pred_1 <- as.double(exp(rf_yHat) - 1)
write.csv(rf_yHat_pred_1, file = "rf_yHat_pred.csv")

# Boosted tree:
set.seed=100
#gbmModel = gbm(  y ~ . , data=trainData) 
gbmModel = gbm.fit( x_train, y_train, distribution="gaussian", n.trees =100, interaction.depth=7, shrinkage=0.1)
summary(gbmModel)
# predict solubility:
gbm_yHat = predict(gbmModel,n.trees = 100, x_test)
gbm_yHat_pred_1 <- as.double(exp(gbm_yHat) - 1)
write.csv(gbm_yHat_pred_1, file = "gbm_yHat_pred.csv")

## create a 10 folds CV control
set.seed(100)
## rpart2 is used to tune max depth 
rpartTune <- train(x_train, y_train, method = "rpart2",tuneLength = 20, trControl = ctrl)
rpartTune
summary(rpartTune)
 # maxdepth  RMSE       Rsquared   MAE
 # 9        0.2145049  0.7102375  0.1588057
rpartTune_pred = predict(rpartTune,x_test)
rpartTune_pred_1 <- as.double(exp(rpartTune_pred) - 1)
write.csv(rpartTune_pred_1, file = "rpartTune_pred.csv")

```

```{r}
##non linear models

#knn model

knnModel = train(x=x_train, y=y_train, method="knn",
                 tuneLength=10, trControl = ctrl,
                 preProc=c("center", "scale"))
knnModel
# k   RMSE       Rsquared   MAE  
# 7  0.1737524  0.8143997  0.1230069
apply(knnModel$resample[, 1:2], 2, sd)
# RMSE   Rsquared 
# 0.01731130 0.03058243 
plot(knnModel)

knnPredtrain = predict(knnModel, newdata=x_train)
knnPRtrain = postResample(pred=knnPredtrain, obs=y_train)
knnPRtrain
# RMSE  Rsquared       MAE 
# 0.1496534 0.8633694 0.1054160
knnPred = predict(knnModel, newdata=x_test)
knnPR = as.data.frame(exp(knnPred))
knnPR
write.csv(knnPR, file = "knnpred.csv")
```

```{r}
#neural net

nnGrid = expand.grid( .decay=c(0,0.01,0.1), .size=1:10 )

set.seed(100)

nnetModel = train(x=x_train, y=y_train, method="nnet", preProc=c("center", "scale"), linout=TRUE, trace=FALSE, MaxNWts=10 * (ncol(x_train)+1) + 10 + 1, maxit=100, tuneGrid = nnGrid)

nnetModel
# decay  size  RMSE       Rsquared   MAE
# 0.10    5    0.2240647  0.7217428  0.1574869
apply(nnetModel$resample[, 1:2], 2, sd)
# RMSE   Rsquared
# 0.06384209 0.11379937
plot(nnetModel)

pred = predict(nnetModel, newdata=x_train)
nnetPRtrain = postResample(pred=pred, obs=y_train)
nnetPRtrain

pred = predict(nnetModel, newdata=x_test)
nnetpred <- as.data.frame(exp(pred))
nnetpred
write.csv(nnetpred, file = "nnetpred.csv")
```

```{r}
#SVM

set.seed(100)

svmRModel = train(x=x_train, y=y_train, method="svmRadial", tuneLength=20, trControl = ctrl, preProc= c("center", "scale"))
svmRModel
# C          RMSE       Rsquared   MAE 
# 2.00  0.1162349  0.9147054  0.07931530
plot(svmRModel)
apply(svmRModel$resample[, 1:2], 2, sd)
# RMSE   Rsquared 
# 0.01628934 0.01965500
svmtrain <- data.frame(obs = y_train, pred = predict(svmRModel, x_train))
svmtrain
defaultSummary(svmtrain)

pred = predict(svmRModel, x_test)
svmpred <- as.data.frame(exp(pred))
write.csv(svmpred, file = "svmpred.csv")
```

```{r}
#MARS

marsGrid = expand.grid(.degree=1:2, .nprune=2:38)

set.seed(100)

marsModel = train(x=x_train, y=y_train, method="earth", tuneGrid=marsGrid, trControl = ctrl, preProc = c("center", "scale"))

marsModel
# degree  nprune  RMSE       Rsquared   MAE    
# 2       36      0.1211108  0.9068691  0.08338364
apply(marsModel$resample[, 1:2], 2, sd)
# RMSE   Rsquared 
# 0.01679566 0.02203292
plot(marsModel)
varImp(marsModel)

marstrain <- data.frame(obs = y_train, pred = predict(marsModel, x_train))
marstrain

colnames(marstrain)<- c("obs","pred")
defaultSummary(marstrain)

pred = predict(marsModel, x_test)
marspred <- as.data.frame(exp(pred))

write.csv(marspred, file = "marspred.csv")
```
